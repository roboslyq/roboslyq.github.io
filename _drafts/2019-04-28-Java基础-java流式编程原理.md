# Java8流式编程原理

>  本文章主要是记录自己初步学习，所以部分资料非本人原创，我会将引用到的相关资料放在最后的`参考资料`中。



## 核心关系图

![1](https://roboslyq.github.io/images/java-core/stream/1.jpg)

![2](https://roboslyq.github.io/images/java-core/stream/2.jpg)

# 传统的foreach原理

## Iterable

```java
public interface Iterable<T> {
    Iterator<T> iterator();
    default void forEach(Consumer<? super T> var1) {
        Objects.requireNonNull(var1);
        Iterator var2 = this.iterator();
        while(var2.hasNext()) {
            Object var3 = var2.next();
            var1.accept(var3);
        }
    }
    default Spliterator<T> spliterator() {
        return Spliterators.spliteratorUnknownSize(this.iterator(), 0);
    }
}
```

## Iterator接口

```java
package java.util;
import java.util.function.Consumer;
public interface Iterator<E> {
    //判断集合中是否还有下一个元素
    boolean hasNext();
    //获取下一个元素
    E next();
    //Iterator默认不可以移除当前元素
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }
    //遍列操作
    default void forEachRemaining(Consumer<? super E> var1) {
        Objects.requireNonNull(var1);
        while(this.hasNext()) {
            var1.accept(this.next());
        }
    }
}
```

## ArralyList实现Iterable

以Arraylist为例，简单讲解如果实现`Iterable`.使用内实现Iterator接口。

```java
public ListIterator<E> listIterator() {
        return new ArrayList.ListItr(0);
    }
public Iterator<E> iterator() {
    return new ArrayList.Itr();
}
//内部类，实现Iterator接口
private class Itr implements Iterator<E> {
    	//因为是数组，所以有序号指定数组位置
        int cursor;
    	//上一次游标位置（为什么这么设计）
        int lastRet;
    	//
        int expectedModCount;

        private Itr() {
            this.lastRet = -1;
            this.expectedModCount = ArrayList.this.modCount;
        }

        public boolean hasNext() {
            return this.cursor != ArrayList.this.size;
        }
    	
        public E next() {
            this.checkForComodification();
            int var1 = this.cursor;
            if (var1 >= ArrayList.this.size) {
                throw new NoSuchElementException();
            } else {
                Object[] var2 = ArrayList.this.elementData;
                if (var1 >= var2.length) {
                    throw new ConcurrentModificationException();
                } else {
                    this.cursor = var1 + 1;
                    return var2[this.lastRet = var1];
                }
            }
        }
		
        public void remove() {
            if (this.lastRet < 0) {
                throw new IllegalStateException();
            } else {
                this.checkForComodification();

                try {
                    ArrayList.this.remove(this.lastRet);
                    this.cursor = this.lastRet;
                    this.lastRet = -1;
                    this.expectedModCount = ArrayList.this.modCount;
                } catch (IndexOutOfBoundsException var2) {
                    throw new ConcurrentModificationException();
                }
            }
        }

        public void forEachRemaining(Consumer<? super E> var1) {
            Objects.requireNonNull(var1);
            int var2 = ArrayList.this.size;
            int var3 = this.cursor;
            if (var3 < var2) {
                Object[] var4 = ArrayList.this.elementData;
                if (var3 >= var4.length) {
                    throw new ConcurrentModificationException();
                } else {
                    while(var3 != var2 && ArrayList.this.modCount == this.expectedModCount) {
                        var1.accept(var4[var3++]);
                    }

                    this.cursor = var3;
                    this.lastRet = var3 - 1;
                    this.checkForComodification();
                }
            }
        }

        final void checkForComodification() {
            if (ArrayList.this.modCount != this.expectedModCount) {
                throw new ConcurrentModificationException();
            }
        }
    }
```

## JVM字节码

- 源码

```java
package test;

import java.util.List;

/**
 * Created by vino on 2016/5/6.
 */
public class TestForeach {
    List<Integer> integers;
    public void testForeach(){
        for(Integer i : integers){

        }
    }
}
```

- 字节码

```java
public void testForeach();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=3, args_size=1
         0: aload_0
         1: getfield      #2                  // Field integers:Ljava/util/List;
         4: invokeinterface #3,  1            // InterfaceMethod java/util/List.iterator:()Ljava/util/Iterator;
         9: astore_1
        10: aload_1
        11: invokeinterface #4,  1            // InterfaceMethod java/util/Iterator.hasNext:()Z
        16: ifeq          32
        19: aload_1
        20: invokeinterface #5,  1  // InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;
        25: checkcast     #6                  // class java/lang/Integer
        28: astore_2
        29: goto          10
        32: return
      LineNumberTable:
        line 11: 0
        line 13: 29
        line 14: 32
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
           29       0     2     i   Ljava/lang/Integer;
            0      33     0  this   Ltest/TestForeach;
```

> 0:加载this到操作栈
>
> 1:获取字段integers
>
> 4:调用integers的接口方法interator
>
> 9:将返回的迭代器赋给本地变量?(我们看到在最下面的本地变量区的Slot列,有0和2,但是没有1.事实上,1就是编译器为我们生成的一个迭代器变量),这边就是给这个迭代器赋值
>
> 底层是通过 goto 实现跳转的。



# Stream 

## 什么是流式编程

Java SE 8 中主要的新语言特性是*拉姆达表达式*。可以将拉姆达表达式想作一种匿名方法；像方法一样，拉姆达表达式具有带类型的参数、主体和返回类型。但真正的亮点不是拉姆达表达式本身，而是它们所实现的功能。拉姆达表达式使得**将行为表达为数据**变得很容易，从而使开发具有更强表达能力、更强大的库成为可能。

所有流计算都有一种共同的结构：它们具有一个***流来源***、***0 或多个中间操作***，以及一个***终止操作***。流的元素可以是对象引用 (`Stream<String>`)，也可以是原始整数 (`IntStream`)、长整型 (`LongStream`) 或双精度 (`DoubleStream`)。

因为 Java 程序使用的大部分数据都已存储在集合中，所以许多流计算使用集合作为它们的来源。JDK 中的 `Collection` 实现都已增强，可充当高效的流来源。但是，还存在其他可能的流来源，比如数组、生成器函数或内置的工厂（比如数字范围），而且可以编写自定义的流适配器，以便可以将任意数据源充当流来源。表 1 给出了 JDK 中的一些流生成方法。

### 表 1. JDK 中的流来源

| 方法                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| `Collection.stream()`                                        | 使用一个集合的元素创建一个流。                               |
| `Stream.of(T...)`                                            | 使用传递给工厂方法的参数创建一个流。                         |
| `Stream.of(T[])`                                             | 使用一个数组的元素创建一个流。                               |
| `Stream.empty()`                                             | 创建一个空流。                                               |
| `Stream.iterate(T first, BinaryOperator<T> f)`               | 创建一个包含序列 `first, f(first), f(f(first)), ...`的无限流 |
| `Stream.iterate(T first, Predicate<T> test, BinaryOperator<T> f)` | （仅限 Java 9）类似于 `Stream.iterate(T first, BinaryOperator<T> f)`，但流在测试预期返回 `false` 的第一个元素上终止。 |
| `Stream.generate(Supplier<T> f)`                             | 使用一个生成器函数创建一个无限流。                           |
| `IntStream.range(lower, upper)`                              | 创建一个由下限到上限（不含）之间的元素组成的`IntStream`。    |
| `IntStream.rangeClosed(lower, upper)`                        | 创建一个由下限到上限（含）之间的元素组成的 `IntStream`。     |
| `BufferedReader.lines()`                                     | 创建一个有来自 `BufferedReader` 的行组成的流。               |
| `BitSet.stream()`                                            | 创建一个由 `BitSet` 中的设置位的索引组成的 `IntStream`。     |
| `Stream.chars()`                                             | 创建一个与 `String` 中的字符对应的 `IntStream`。             |





# 参考资料

https://www.cnblogs.com/vinozly/p/5465454.html

http://www.cnblogs.com/CarpenterLee/p/6637118.html

https://www.ibm.com/developerworks/cn/java/j-java-streams-1-brian-goetz/index.html

