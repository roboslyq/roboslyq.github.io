

# 1. 2-3-4树的定义

2-3-4树是一种阶为4的B树。它是一种自平衡的数据结构，可以保证在O(lgn)的时间内完成查找、插入和删除操作。它主要满足以下性质：

（1）每个节点每个节点有1、2或3个key，分别称为2（孩子）节点，3（孩子）节点，4（孩子）节点。

（2）**所有叶子节点到根节点的长度一致**（也就是说叶子节点都在同一层）。

（3）每个节点的key从左到右保持了从小到大的顺序，两个key之间的子树中所有的key一定大于它的父节点的左key，小于父节点的右key。

![img](https://images2015.cnblogs.com/blog/834468/201611/834468-20161128200810193-1147769312.png)

# 2. 插入操作

（1）如果2-3-4树中已存在当前插入的key，则插入失败，否则最终一定是在叶子节点中进行插入操作

（2）如果待插入的节点不是4节点，那么直接在该节点插入

（3）如果待插入的节点是个4节点，那么应该先分裂该节点然后再插入。一个4节点可以分裂成一个根节点和两个子节点（这三个节点各含一个key）然后在子节点中插入，我们把分裂形成的根节点中的key看成向上层插入的key，然后重复第2步和第3步。

   如果是在4节点中进行插入，每次插入会多出一个分支，如果插入操作导致根节点分裂，则2-3-4树会生长一层。

![image](https://images2015.cnblogs.com/blog/834468/201611/834468-20161128200841881-459706638.png) 



![image](https://images2015.cnblogs.com/blog/834468/201611/834468-20161128201047990-1032593183.png) 

![image](https://images2015.cnblogs.com/blog/834468/201611/834468-20161128201057771-1775134579.png) 

![image](https://images2015.cnblogs.com/blog/834468/201611/834468-20161128201109740-1922677266.png) 

![image](https://images2015.cnblogs.com/blog/834468/201611/834468-20161128201119849-993942361.png) 

# 3. 删除操作

（1）如果2-3-4树中不存在当前需要删除的key，则删除失败。

（2）如果当前需要删除的key不位于叶子节点上，则用后继key覆盖，然后在它后继

key所在的子支中删除该后继key。

（3）如果当前需要删除的key位于叶子节点上:

​       （3.1）该节点不是2节点，删除key，结束

> 不是2节点，删除其中一个，不影响树结构

​       （3.2）该节点是2节点，删除该节点：

​              （3.2.1）如果兄弟节点不是2节点，则父节点中的key下移到该节点，兄弟节点中的一个key上移

> 兄弟节点为多个KEY，兄弟节点可以借一个KEY作为父节点，然后当前父节点补齐到当前节点位置。保持树平衡。

​             （3.2.2）如果兄弟节点是2节点，父节点是个3节点或4节点，父节点中的key与兄弟节点合并

> 兄弟节点是2节点，父亲节点有多个，

​             （3.2.3）如果兄弟节点是2节点，父节点是个2节点，父节点中的key与兄弟节点中的key合并，形成一个3节点，把此节点看成当前节点（此节点实际上是下一层的节点），重复步骤3.2.1到3.2.3

   如果是在2节点（叶子节点）中进行删除，每次删除会减少一个分支，如果删除操作导致根节点参与合并，则2-3-4树会降低一层。

[![image](https://images2015.cnblogs.com/blog/834468/201611/834468-20161128201129396-1044795488.png)](http://images2015.cnblogs.com/blog/834468/201611/834468-20161128201125849-75328454.png)

------

[![image](https://images2015.cnblogs.com/blog/834468/201611/834468-20161128201139959-1656707091.png)](http://images2015.cnblogs.com/blog/834468/201611/834468-20161128201136365-425935986.png)

[![image](https://images2015.cnblogs.com/blog/834468/201611/834468-20161128201155646-1631962506.png)](http://images2015.cnblogs.com/blog/834468/201611/834468-20161128201150459-506302025.png)

------

[![image](https://images2015.cnblogs.com/blog/834468/201611/834468-20161128201208709-402437322.png)](http://images2015.cnblogs.com/blog/834468/201611/834468-20161128201203818-698300195.png)

------

[![image](https://images2015.cnblogs.com/blog/834468/201611/834468-20161128201219584-1452203403.png)](http://images2015.cnblogs.com/blog/834468/201611/834468-20161128201215099-283896678.png)

# 4. 带有预分裂的插入操作

上面的插入以及删除操作在某些情况需要不断回溯来调整树的结构以达到平衡。为了消除回溯过程，在插入操作过程中我们可以采取预分裂的操作，即我们在插入的搜索路径中，遇到4节点就分裂（分裂后形成的根节点的key要上移，与父节点中的key合并）这样可以保证找到需要插入节点时可以直接插入（即该节点一定不是4节点）

[![image](https://images2015.cnblogs.com/blog/834468/201611/834468-20161128201236771-1328683837.png)](http://images2015.cnblogs.com/blog/834468/201611/834468-20161128201227349-2063809375.png)

------

 

[![image](https://images2015.cnblogs.com/blog/834468/201611/834468-20161128201248224-1065457578.png)](http://images2015.cnblogs.com/blog/834468/201611/834468-20161128201243662-429595738.png)

------

[![image](https://images2015.cnblogs.com/blog/834468/201611/834468-20161128201258193-1627661647.png)](http://images2015.cnblogs.com/blog/834468/201611/834468-20161128201254162-310729849.png)

------

[![image](https://images2015.cnblogs.com/blog/834468/201611/834468-20161128201307537-371811308.png)](http://images2015.cnblogs.com/blog/834468/201611/834468-20161128201303177-1753415917.png)

------

[![image](https://images2015.cnblogs.com/blog/834468/201611/834468-20161128201317599-93247072.png)](http://images2015.cnblogs.com/blog/834468/201611/834468-20161128201313959-676436214.png)

------

[![image](https://images2015.cnblogs.com/blog/834468/201611/834468-20161128201328974-1935812730.png)](http://images2015.cnblogs.com/blog/834468/201611/834468-20161128201326084-2004877146.png)

# 5. 带有预合并的删除操作

在删除过程中，我们同样可以采取预合并的操作，即我们在删除的搜索路径中（除根节点，因为根节点没有兄弟节点和父节点），遇到当前节点是2节点，如果兄弟节点也是2节点就合并（该节点的父节点中的key下移，与自身和兄弟节点合并）；如果兄弟节点不是2节点，则父节点的key下移，兄弟节点中的key上移。这样可以保证，找到需要删除的key所在的节点时可以直接删除（即要删除的key所在的节点一定不是2节点）。

[![image](https://images2015.cnblogs.com/blog/834468/201611/834468-20161128201345381-716276777.png)](http://images2015.cnblogs.com/blog/834468/201611/834468-20161128201337412-1568864646.png)

------

[![image](https://images2015.cnblogs.com/blog/834468/201611/834468-20161129214202599-1767285757.png)](http://images2015.cnblogs.com/blog/834468/201611/834468-20161129214156662-343715252.png)

这里包含key为60的节点也可以选择让父节点中的key 76下移和兄弟节点中的83合并，两种方式都能达到B树的平衡，这也是在2-3-4树对应的红黑树中使用的方式。

------

[![image](https://images2015.cnblogs.com/blog/834468/201611/834468-20161128201700896-96556693.png)](http://images2015.cnblogs.com/blog/834468/201611/834468-20161128201657146-854975674.png)

------

[![image](https://images2015.cnblogs.com/blog/834468/201611/834468-20161128201830334-1932720948.png)](http://images2015.cnblogs.com/blog/834468/201611/834468-20161128201824584-1628940527.png)

------

[![image](https://images2015.cnblogs.com/blog/834468/201611/834468-20161128201844115-1618187572.png)](http://images2015.cnblogs.com/blog/834468/201611/834468-20161128201839724-838382876.png)

# 2.定义

**红黑**树是每个节点都带有颜色属性的**二叉查找树**，颜色或红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:

​	性质1. 节点是红色或黑色。

　　性质2. 根节点是黑色。

　　性质3 每个叶节点（NIL节点，空节点）是黑色的。

> 可以用来评判条件5

　　性质4  每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

> 红色节点不能连续

　　性质5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

　　这些约束强制了红黑树的关键性质: **从根到叶子的最长的可能路径不多于最短的可能路径的两倍长**。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。

# 3.旋转

二次旋转，特殊情况先调整成相同方向，再做旋转。



# 参考资料

http://www.mamicode.com/info-detail-2024883.html

https://www.cnblogs.com/skywang12345/p/3245399.html

https://www.cnblogs.com/nullzx/p/6111175.html

https://www.cnblogs.com/nullzx/p/6128416.html