---
layout: post
title:  "打卡(201903)"
categories: 每天打卡
tags:  每天打卡
author: roboslyq
---
* content
{:toc}
# 3月



##　３月16号 星期六

### Java刷题小分队

1、Java中的同步集合与并发集合有什么区别？

- 为什么需要同步和并发集合
  - 普通集合没有添加同步和并发控制，在多线程环境下不是线程安全的。为了解决线程安全问题，于是出现了同步和并发集合。
- 同步集合与并发集合

​	所谓同步集合和并发集合，差异主要在同步和并发上。同步即使用synchronize锁的方式来达到线程安全。而并发则不同。它可以与同步集合一样使用synchronize来达到线程安全，但进行优化引入了segment（分段锁）的概念。因此性能比synchronize的要高。同样也可以使用CopyOnWrite技术，达实现多线和安全效果。
2、Java中invokeAndWait 和 invokeLater有什么区别？

- 相同点

  都是将代码交给另一个线程(EDT)去处理，并且是有序的

- 不同点

  `invokeLater`是异步非阻塞模式的，不需要等待代码执行结果就返回继续往下执行。

  `invokeAndWait`从名字可以看出来，需要等待执行结果。

3、什么是FutureTask？

首先看看FutureTask继承关系图：

```mermaid
graph BT
RunnableFuture --> Future
RunnableFuture --> Runnable
FutureTask --> RunnableFuture

```

从图中可知FutureTask实现了RunnableFuture接口，而RunnableFuture继承了Runnable和Future，也就是说FutureTask既是Runnable，也是Future。

FutureTask个人认为有两个相对于传统的Thread或者Runnable接口，比较有特色特性如下：

1. 有返回值，可以获取执行结果
2. 任务可以取消



### 参考资料

[FutureTask源码解析](https://www.cnblogs.com/linghu-java/p/8991824.html)

---

## 3月15号 星期五

### Java刷题小分队

1、线程池作用，主要实现类，并说出实现类场景以及区别

 **作用**

- 频繁创建线程开销较大，减少线程创建的需要消耗
- 线程池中的线程可以重复利用，提高资源的利用率
- 使用线程池可以对并发量进行相关控制

**实现类**

- `ThreadPoolExecutor`

> 如果忘记这个类，可以通过`Executors`这个最常用类，去查找相关实现。如果连`Executors`也忘记了，那得好好复习了。
>
> ThreadPoolExecutor -->AbstractExecutorService-->ExecutorService-->Executor

2、ThreadPoolExecutor使用场景。以及原理

​	关于使用场景，我们也可以通过`Executors`查看以new开头的相关方法：![gc](..\images\dailywork\mar2019\threadPools.jpg)

> 这种方法命名很规范，从命名中我们就大概知道每个ThreadPool使用场景
>
> 常见的比如：newFixedThreadPool(int) : 创建固定数据的连接池。此连接池大小固定，不会自动调整或者改变。如要请求数大于可用线程数，则请求进入队列池里。
>
> newShceduledPool():延迟或者定时执行任务的线程池。

3、Executor拒绝策略说的是什么？

`AbortPolicy`:丢弃任务并抛出RejectedExecutionException异常。
 `DiscardPolicy`：丢弃任务，但是不抛出异常。
`DiscardOldestPolicy`：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
`CallerRunsPolicy`：由调用线程处理该任务

4、无界阻塞延迟队列delayqueue原理是什么？

​	关于DelayQueue的原理，就不详细介绍了，网上很多资料。在这里总结这个Queue的一个坑。

​	`DelayQueue`指定的默认处时时间单位是纳秒，所以所以这个值设置的很少，会导致自旋频率过快，然后 导致很占CPU。

5、CyclicBarrier和CountDownLatch的区别？

| CountDownLatch                                               | CyclicBarrier                                                |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 减计数方式                                                   | 加计数方式                                                   |
| 计算为0时释放所有等待的线程                                  | 计数达到指定值时释放所有等待线程                             |
| 计数为0时，无法重置                                          | 计数达到指定值时，计数置为0重新开始                          |
| 调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响 | 调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞 |
| 不可重复利用                                                 | 可重复利用                                                   |



### JDK的String类源码注释分析

### 周志明深入理解JVM虚拟机**第二章和第三章**

### 完成下面试题验证

![gc](..\images\dailywork\mar2019\gc.jpg)



---



## 3月14号 星期四

### 刷题小分队
​	1、 线程类的构造方法、静态块是被哪个线程调用的?
​	2、 同步方法和同步块，哪个是更好的选择?
​	3、如何检测死锁？怎么预防死锁？









